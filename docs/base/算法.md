# 10.算法

## 1.两数之和（leetcode 1） ⭐

题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

>你可以按任意顺序返回答案。

```js
function twoSum(nums, target) {
    const visited = new Map()
    for (let i = 0; i < nums.length; i++) {
        const diff = target - nums[i]
        if (visited.has(diff)) {
            return [visited.get(diff), i]
        }
        visited.set(nums[i], i)
    }
}
```

以上思路的时间复杂度和空间复杂度都是O(n)

## 2.二叉树的前序遍历（leetcode 144） ⭐

题目：给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

```js
// 根-左-右
function preOrder(root) {
    if (!root) return []
    const stack = [root]
    const res = []
    while (stack.length) {
        const node = stack.pop()
        res.push(node.val)
        if (node.right) stack.push(node.right)
        if (node.left) stack.push(node.left)
    }
    return res
}
```

## 3.快速排序

解题思路：

- 1.将序列分为较大和较小的两个子序列

- 2.选取一个基准值对序列进行拆分

- 3.通过与基准值比大小递归排序子序列

```js
function quickSort(arr) {
    if (arr.length <= 1) return arr
    const len = arr.length - 1
    const pivot = arr[len]
    const left = []
    const right = []
    for (let i = 0; i < len; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i])
        } else {
            right.push(arr[i])
        }
    }
    return [...quickSort(left), pivot, ...quickSort(right)]
}
const array = [3, 6, 8, 10, 1, 2, 1];
console.log(quickSort(array));
```

## 4.冒泡排序

## 5.选择排序

## 3.二叉树的层序遍历（leetcode 102）

题目：给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。

```js
// 根-左-右 层 队列
function treeNode(root) {
    if (!root) return []
    const queue = [root]
    const res = []
    while (queue.length > 0) {
        const levelLength = queue.length
        const levelArr = []
        for (let i = 0; i < levelLength; i++) {
            const current = queue.shift()
            levelArr.push(current.val)
            if (current.left) queue.push(current.left)
            if (current.right) queue.push(current.right)
        }
        res.push(levelArr)
    }
    return res
}
```

## 4.二叉树中序遍历（leetcode 94）

题目：给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。

```js
// 左-根-右 栈
function inOrder(root) {
    const stack = []
    const res = []
    let node = root
    while (node || stack.length) {
        while (node) {
            stack.push(node)
            node = node.left
        }
        node = stack.pop()
        res.push(node.val)
        node = node.right
    }
    return res
}
```

## 5.二叉树后序遍历（leetcode 145）

题目：给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。

```js
// 左-右-根 栈
function postOrder(root) {
    if (!root) return []
    const stack = [root]
    const res = []
    while (stack.length) {
        const node = stack.pop()
        res.push(node.val)
        if (node.left) stack.push(node.left)
        if (node.right) stack.push(node.right)
    }
    return res.reverse()
}
```

>后序将前序变一下再翻转一下就行了，前序是：根 => 左 => 右，将前序先变成：根 => 右 => 左，再翻转过来就是后序了：左 => 右 => 根。

## 6.删除链表的倒数第 N 个结点（leetcode 19）

题目：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

```js
// 双指针
function listNode(head, n) {
    const dummy = new ListNode(0, head)
    let first = dummy
    let second = dummy
    for (let i = 0; i < n + 1; i++) {
        first = first.next
    }
    while (first !== null) {
        first = first.next
        second = second.next
    }
    second.next = second.next.next
    return dummy.next
}
```

## 7.删除排序链表中的重复元素（leetcode 83）

题目：给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。

```js
function listNode(head) {
    let current = head
    while (current && current.next) {
        if (current.val === current.next.val) {
            current.next = current.next.next
        } else {
            current = current.next
        }
    }
    return head
}
```

## 8.删除排序链表中的重复元素 II（leetcode 82）

题目：给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。

```js
function deleteDuplicates(head) {
    const dummy = new ListNode(0, head)
    let prev = dummy
    let current = head
    while (current) {
        let flag = false
        while (current.next && current.val === current.next.val) {
            flag = true
            current = current.next
        }
        if (flag) {
            prev.next = current.next
        } else {
            prev = current
        }
        current = current.next
    }
    return dummy.next
}
```

## 9.合并两个有序数组（leetcode 88）

题目：给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

```js
function merge(nums1, m, nums2, n) {
    let i = m - 1
    let j = n - 1
    let k = m + n - 1

    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    while (j >= 0) {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

## 10.旋转链表（leetcode 61）

题目：给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。

```js
function rotateRight(head, k) {
    if (!head || !head.next || k === 0) return head
    // 计算链表长度
    let oldTail = head
    let n = 1
    while (oldTail.next) {
        oldTail = oldTail.next
        n++
    }
    // 计算链表需要移动的真实步数
    let steps = n - k % n
    // 将链表变成循环链表
    oldTail.next = head
    // 找到新的头部和尾部并断开
    let newTail = head
    for (let i = 1; i < steps; i++) {
        newTail = newTail.next
    }
    let newHead = newTail.next
    newTail.next = null
    return newHead
}
```

## 11. 无重复字符的最长子串（leetcode 3）

题目：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

```js
function lengthOfLongestSubstring(s) {
    let start = 0
    let end = 0
    let maxLength = 0
    let seenChars = new Map()

    while (end < s.length) {
        if (!seenChars.has(s[end])) {
            seenChars.set(s[end], end)
            end++
            maxLength = Math.max(maxLength, end - start)
        } else {
            seenChars.delete(s[start])
            start++
        }
    }
    return maxLength
}
```

## 12.回溯算法

## 13.单链表反转

## 14.两个数组的交集 II（leetcode 350）

题目：给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

```js
function intersect(nums1, nums2) {
  const map = {}
  const res = []

  for (let num of nums1) {
    if (map[num]) {
      map[num]++
    } else {
      map[num] = 1
    }
  }
  for (let num of nums2) {
    if (map[num] > 0) {
      res.push(num)
      map[num]--
    }
  }
  return res
}
```

## 15.二叉树的最大深度（leetcode 104）

题目：给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。

```js
function maxDepth(root) {
    if (!root) return 0
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
}
```

>这题递归过程的详细讲解[参考视频资料](https://www.bilibili.com/video/BV1g741137Wq/?spm_id_from=333.788.recommend_more_video.-1&vd_source=311687dcd0c3d8fd13fcbe93ce43465c)

## 16.翻转二叉树（leetcode 226）

题目：给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

```js
function invertTree(root) {
    if (!root) return null
    [root.left, root.right] = [root.right, root.left]
    invertTree(root.left)
    invertTree(root.right)
    return root
}
```

## 17.对称二叉树（leetcode 101）

题目：给你一个二叉树的根节点 root ， 检查它是否轴对称。

```js
function isSymmetric(root) {
    if (!root) return true
    const queue = [root.left, root.right]
    while (queue.length) {
        const node1 = queue.shift()
        const node2 = queue.shift()
        if (!node1 && !node2) continue;
        if (!node1 || !node2) return false
        if (node1.val !== node2.val) return false
        queue.push(node1.left, node2.right, node1.right, node2.left)
    }
    return true
}
```

## 18.二叉树的直径（leetcode 543）

题目：给你一棵二叉树的根节点，返回该树的 直径 。二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。两节点之间路径的 长度 由它们之间边数表示。

```js
function diameterOfBinaryTree(root) {
    let diameter = 0;
    function depth(node) {
        if (!node) return 0
        const left = depth(node.left)
        const right = depth(node.right)
        diameter = Math.max(diameter, left + right)
        return Math.max(left, right) + 1
    }
    depth(root)
    return diameter
}
```

## 19.将有序数组转换为二叉搜索树（leetcode 108）

题目：给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

```js
function sortedArrayToBST(nums) {
    if (!nums.length) return null
    function buildTree(left, right) {
        if (left > right) return null
        const mid = Math.floor((left + right) / 2)
        const root = new TreeNode(nums[mid])
        root.left = buildTree(left, mid - 1)
        root.right = buildTree(mid + 1, right)
        return root
    }
    return buildTree(0, nums.length - 1)
}
```

## 20.验证二叉搜索树（leetcode 98）

题目：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。有效 二叉搜索树定义如下：节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。

```js
function isValidBST(root) {
    // 左 < 根 < 右
    const stack = []
    const res = []
    let node = root
    while (node || stack.length) {
        while (node) {
            stack.push(node)
            node = node.left
        }
        node = stack.pop()
        res.push(node.val)
        node = node.right
    }
    for (let i = 0; i < res.length - 1; i++) {
        if (res[i] >= res[i + 1]) {
            return false
        }
    }
    return true
}
```

## 21.二叉搜索树中第K小的元素（leetcode 230）

[题目链接](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&envId=top-100-liked)

```js
function kthSmallest(root, k) {
    // 左 < 根 < 右
    const stack = []
    const res = []
    let node = root
    while (node || stack.length) {
        while (node) {
            stack.push(node)
            node = node.left
        }
        node = stack.pop()
        res.push(node.val)
        node = node.right
    }
    return res[k - 1]
}
```

## 22.二叉树的右视图（leetcode 199）

[题目链接](https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-100-liked)

```js
function rightSideView(root) {
    if (!root) return [];
    // 层序
    const queue = [root]
    const res = []
    while (queue.length) {
        const levelSize = queue.length
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift()
            if (i === levelSize - 1) {
                res.push(node.val)
            }
            if (node.left) queue.push(node.left)
            if (node.right) queue.push(node.right)
        }
    }
    return res
}
```

## 23.二叉树展开为链表（leetcode 114）

[题目链接](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)

```js
function flatten(root) {
    if (!root) return;
    const stack = [root]
    let prev = null
    while (stack.length) {
        const node = stack.pop()
        if (prev) {
            prev.right = node
            prev.left = null
        }
        if (node.right) stack.push(node.right)
        if (node.left) stack.push(node.left)
        prev = node
    }
}
```

## 24.从前序与中序遍历序列构造二叉树（leetcode 105）

[题目链接](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)

```js
function buildTree(preorder, inorder) {
    let preIndex = 0;
    const map = new Map()
    for (let i = 0; i < inorder.length; i++) {
        map.set(inorder[i], i)
    }
    function constructTree(left, right) {
        if (left > right) return null;
        const rootVal = preorder[preIndex++]
        const root = new TreeNode(rootVal)
        const index = map.get(rootVal)
        root.left = constructTree(left, index - 1)
        root.right = constructTree(index + 1, right)
        return root
    }
    return constructTree(0, inorder.length - 1)
}
```

## 25.路径总和 III（leetcode 437）

[题目链接](https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked)

```js
function pathSum(root, targetSum) {
    let count = 0
    const map = new Map()
    map.set(0, 1)
    function dfs(node, currSum) {
        if (!node) return;
        currSum += node.val
        count += map.get(currSum - targetSum) || 0
        map.set(currSum, (map.get(currSum) || 0) + 1)
        dfs(node.left, currSum)
        dfs(node.right, currSum)
        map.set(currSum, map.get(currSum) - 1)
    }
    dfs(root, 0)
    return count
}
```

## 26.二叉树的最近公共祖先（leetcode 236）

[题目链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

```js
function lowestCommonAncestor(root, p, q) {
    const parentMap = new Map()
    function dfs(node, parent) {
        if (!node) return;
        parentMap.set(node, parent)
        if (node.left) dfs(node.left, node)
        if (node.right) dfs(node.right, node)
    }
    dfs(root, null)
    const pSet = new Set()
    while (p) {
        pSet.add(p)
        p = parentMap.get(p)
    }
    while (q) {
        if (pSet.has(q)) {
            return q
        }
        q = parentMap.get(q)
    }
    return null
}
```

## 27.二叉树中的最大路径和（leetcode 124）

[题目链接](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

```js
function maxPathSum(root) {
    let maxSum = Number.MIN_SAFE_INTEGER;
    function dfs(node) {
        if (!node) return 0;
        const leftPath = Math.max(dfs(node.left), 0)
        const rightPath = Math.max(dfs(node.right), 0)
        const newPathSum = node.val + leftPath + rightPath
        maxSum = Math.max(maxSum, newPathSum)
        return node.val + Math.max(leftPath, rightPath)
    }
    dfs(root)
    return maxSum
}
```

>所有二叉树算法题目的关键基础是：掌握二叉树的层序、前序、中序、后序遍历的迭代法和递归法，这样遇到二叉树算法题目的时候解题基本上都会有思路。

## 28.叶子相似的树（leetcode 872）

[题目链接](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

```js
function leafSimilar(root1, root2) {
    const levels1 = [], levels2 = [];
    function dfs(node, levels) {
        if (!node) return;
        if (!node.left && !node.right) {
            levels.push(node.val)
        }
        dfs(node.left, levels)
        dfs(node.right, levels)
    }
    dfs(root1, levels1)
    dfs(root2, levels2)
    return JSON.stringify(levels1) === JSON.stringify(levels2)
}
```

## 29.字母异位词分组（leetcode 49）

[题目链接](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

```js
var groupAnagrams = function (strs) {
    const map = {}
    for (let str of strs) {
        let sorted = str.split('').sort().join()
        if (!map[sorted]) {
            map[sorted] = []
        }
        map[sorted].push(str)
    }
    return Object.values(map)
}
```

## 30.最长连续序列（leetcode 128）

[题目链接](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)

```js
var longestConsecutive = function (nums) {
    const set = new Set(nums)
    let lastSum = 0
    for (let num of set) {
        if (!set.has(num - 1)) {
            let currentNum = num
            let sum = 1
            while (set.has(currentNum + 1)) {
                currentNum += 1
                sum += 1
                set.delete(currentNum)
            }
            lastSum = Math.max(lastSum, sum)
        }
    }
    return lastSum
}
```

## 31.盛最多水的容器（leetcode 11）

[题目链接](https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked)

```js
var maxArea = function (height) {
    let left = 0;
    let right = height.length - 1
    let maxArea = 0;
    while (left < right) {
        let h = Math.min(height[left], height[right])
        let w = right - left
        maxArea = Math.max(maxArea, h * w)
        if (height[left] < height[right]) {
            left++
        } else {
            right--;
        }
    }
    return maxArea
}
```

## 32. 三数之和（leetcode 15）

[题目链接](https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked)

```js
var threeSum = function (nums) {
    // 1.对数组进行排序
    nums.sort((a, b) => a - b)
    const res = []
    // 2.遍历数组
    for (let i = 0; i < nums.length - 2; i++) {
        // 数字相同的话跳过循环
        if (i > 0 && nums[i] === nums[i - 1]) continue
        // 设置双指针
        let left = i + 1
        let right = nums.length - 1
        // 双指针内部循环
        while (left < right) {
            let sum = nums[i] + nums[left] + nums[right]
            if (sum === 0) {
                res.push([nums[i], nums[left], nums[right]])
                // 跳过重复数字
                while (nums[left] === nums[++left]);
                while (nums[right] === nums[--right]);
            } else if (sum < 0) {
                left++
            } else {
                right--
            }
        }
    }
    return res
};
```

## 33. 接雨水（leetcode 42）

[题目链接](https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked)

```js
// 双指针
var trap = function (height) {
    let left = 0, right = height.length - 1, res = 0;
    let leftMax = 0, rightMax = 0;
    while (left < right) {
        leftMax = Math.max(leftMax, height[left])
        rightMax = Math.max(rightMax, height[right])
        if (leftMax < rightMax) {
            res += leftMax - height[left]
            left++
        } else {
            res += rightMax - height[right]
            right--
        }
    }
    return res
};
```
