(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{318:function(t,_,v){"use strict";v.r(_);var o=v(14),s=Object(o.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"_8-计算机原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-计算机原理"}},[t._v("#")]),t._v(" 8.计算机原理")]),t._v(" "),_("h2",{attrs:{id:"_1-http2新增-http3做了哪些优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-http2新增-http3做了哪些优化"}},[t._v("#")]),t._v(" 1.http2新增，http3做了哪些优化")]),t._v(" "),_("blockquote",[_("p",[t._v("1.http2大幅度的提升了网页的性能。")])]),t._v(" "),_("blockquote",[_("p",[t._v("2.http2是一个二进制协议，http1是一个超文本协议。")])]),t._v(" "),_("blockquote",[_("p",[t._v("3.http2遵循多路复用，同一域名下的内容只建立一次连接。")])]),t._v(" "),_("blockquote",[_("p",[t._v("4.http2会压缩请求头内容，http1不会进行压缩。")])]),t._v(" "),_("blockquote",[_("p",[t._v("5.http2允许服务器预先将网页所需要的资源PUSH到浏览器内存中。")])]),t._v(" "),_("blockquote",[_("p",[t._v("缺点，还未解决队头阻塞问题。")])]),t._v(" "),_("h2",{attrs:{id:"_2-http-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-http-3"}},[t._v("#")]),t._v(" 2. HTTP/3")]),t._v(" "),_("p",[t._v("HTTP/3 基于之前的 HTTP/2 版本，进一步作出了以下优化：")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("QUIC 协议")]),t._v(": 最重要的变化是从 TCP 转向 QUIC（基于 UDP）。这使得连接更快，减少了往返时延（RTT）。")]),t._v(" "),_("li",[_("strong",[t._v("更好的多路复用")]),t._v(": 由于 QUIC 的设计，其多路复用不再受到“队头阻塞”（Head-of-line blocking）的影响。")]),t._v(" "),_("li",[_("strong",[t._v("0-RTT 连接（Zero Round Trip Time）")]),t._v(" : QUIC 支持 0-RTT 连接，进一步减少了握手的延时。")]),t._v(" "),_("li",[_("strong",[t._v("内置的 TLS 1.3")]),t._v(": 相比 HTTP/2 需要额外的 TLS 握手，HTTP/3 的 QUIC 协议已经内置了 TLS 1.3，提供更强的安全性。")]),t._v(" "),_("li",[_("strong",[t._v("更好的流量控制和拥塞控制")]),t._v(": QUIC 提供了比 TCP 更先进的流量控制和拥塞控制机制。")]),t._v(" "),_("li",[_("strong",[t._v("更灵活的错误恢复")]),t._v(": QUIC 设计使得单个流的问题不会影响到其他流。")]),t._v(" "),_("li",[_("strong",[t._v("更简单的网络路由")]),t._v(": 由于 HTTP/3 使用的是 UDP，所以在某些复杂的网络环境（如移动网络、多路径网络）中可能表现得更好。")])]),t._v(" "),_("h2",{attrs:{id:"_3-http1-1和http2的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-http1-1和http2的区别"}},[t._v("#")]),t._v(" 3.http1.1和http2的区别")]),t._v(" "),_("h3",{attrs:{id:"http-1-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[t._v("#")]),t._v(" HTTP/1.1")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("文本协议")]),t._v(": HTTP/1.1 是基于文本的，这使得它易于阅读和调试。")]),t._v(" "),_("li",[_("strong",[t._v("连接")]),t._v(": 每个请求都需要一个新的 TCP 连接，或者使用持久连接（keep-alive）来减少多次建立和断开连接的开销。")]),t._v(" "),_("li",[_("strong",[t._v("队列阻塞（Head-of-Line Blocking）")]),t._v(" : 在持久连接中，即使是并行发出的多个请求也必须一个接一个地得到响应，这会导致队列阻塞问题。")]),t._v(" "),_("li",[_("strong",[t._v("无服务器推送")]),t._v(": 服务器不能主动将资源推送给客户端，除非客户端明确请求。")]),t._v(" "),_("li",[_("strong",[t._v("头部冗余")]),t._v(": 每次请求都会携带相同的头信息，导致数据传输的低效。")])]),t._v(" "),_("h3",{attrs:{id:"http-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-2"}},[t._v("#")]),t._v(" HTTP/2")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("二进制协议")]),t._v(": HTTP/2 使用二进制格式，这使得解析、网络传输更高效。")]),t._v(" "),_("li",[_("strong",[t._v("多路复用")]),t._v(": 单一的 TCP 连接可以处理多个请求和响应，减少了因多次建立和关闭连接导致的延迟。")]),t._v(" "),_("li",[_("strong",[t._v("服务器推送")]),t._v(": 服务器可以预先推送客户端可能需要的资源，提高页面加载速度。")]),t._v(" "),_("li",[_("strong",[t._v("首部压缩")]),t._v(": 使用 HPACK 算法压缩请求和响应头，以减少数据传输量。")]),t._v(" "),_("li",[_("strong",[t._v("流量控制")]),t._v(": 提供了更精细的流量控制机制，包括对单一流（stream）的控制。")]),t._v(" "),_("li",[_("strong",[t._v("优先级")]),t._v(": 允许设置请求的优先级，使得重要的请求能更快地得到响应。")])]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("TCP")]),t._v(" 是一个可靠、面向连接的协议，适用于需要确保完整和准确传输的应用。")]),t._v(" "),_("li",[_("strong",[t._v("UDP")]),t._v(" 是一个不可靠、无连接的协议，适用于对实时性要求较高或能容忍数据丢失的应用")])]),t._v(" "),_("h2",{attrs:{id:"_4-tcp的3次握手和4次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-tcp的3次握手和4次挥手"}},[t._v("#")]),t._v(" 4.tcp的3次握手和4次挥手？")]),t._v(" "),_("h3",{attrs:{id:"_3次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3次握手"}},[t._v("#")]),t._v(" 3次握手")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("SYN")]),t._v(": 客户端发送一个 TCP 数据包给服务器，请求建立连接。该数据包的 SYN 标志位被设置为 1。")]),t._v(" "),_("li",[_("strong",[t._v("SYN-ACK")]),t._v(": 服务器收到 SYN 数据包后，发送一个新的 TCP 数据包，其 SYN 和 ACK 标志位都被设置为 1，以确认 SYN 数据包已经收到。")]),t._v(" "),_("li",[_("strong",[t._v("ACK")]),t._v(": 最后，客户端再次发送一个 TCP 数据包，其 ACK 标志位被设置为 1，以确认它已经收到服务器的 SYN-ACK 数据包。")])]),t._v(" "),_("h3",{attrs:{id:"四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("FIN（终止请求）")]),t._v(" : 当一方（通常是客户端，但也可能是服务器）完成数据发送并希望关闭连接时，它会发送一个TCP包，其中设置了"),_("code",[t._v("FIN")]),t._v("（Finish）标志位，来通知另一方它想要终止连接。")]),t._v(" "),_("li",[_("strong",[t._v("ACK（确认）")]),t._v(" : 收到"),_("code",[t._v("FIN")]),t._v("包的一方（通常是服务器）会发送一个"),_("code",[t._v("ACK")]),t._v("（Acknowledgment，确认）包来确认已经收到"),_("code",[t._v("FIN")]),t._v('包。这一步并不会立即关闭连接，它只是告诉对方"我知道你想要关闭连接了"。')]),t._v(" "),_("li",[_("strong",[t._v("FIN（终止请求）")]),t._v(" : 服务器完成最后的数据发送后，也会发送一个设置了"),_("code",[t._v("FIN")]),t._v("标志位的TCP包给客户端，来请求关闭连接。")]),t._v(" "),_("li",[_("strong",[t._v("ACK（确认）")]),t._v(" : 最后，客户端收到服务器的"),_("code",[t._v("FIN")]),t._v("包后，会发送一个"),_("code",[t._v("ACK")]),t._v("包作为回应，确认已经收到服务器的终止请求。收到这个"),_("code",[t._v("ACK")]),t._v("包后，服务器关闭连接。")])]),t._v(" "),_("h2",{attrs:{id:"_6-get和post区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-get和post区别"}},[t._v("#")]),t._v(" 6.get和post区别？")]),t._v(" "),_("blockquote",[_("p",[t._v("1.get传参通过url地址传递，post传参方式url不可见")])]),t._v(" "),_("blockquote",[_("p",[t._v("2.post更加的安全")])]),t._v(" "),_("blockquote",[_("p",[t._v("3.get请求可以被缓存，post不可以被缓存")])]),t._v(" "),_("blockquote",[_("p",[t._v("4.get请求有长度限制，因为URL长度是限制的，post请求没有长度限制。")])]),t._v(" "),_("h2",{attrs:{id:"_7-说一说常见的状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-说一说常见的状态码"}},[t._v("#")]),t._v(" 7.说一说常见的状态码？")]),t._v(" "),_("blockquote",[_("p",[t._v("1xx (信息响应)")])]),t._v(" "),_("p",[t._v("101 Switching Protocols: 服务器已理解并准备切换协议。")]),t._v(" "),_("blockquote",[_("p",[t._v("2xx (成功)")])]),t._v(" "),_("p",[t._v("200 OK: 请求成功。具体的操作取决于所用的请求方法。")]),t._v(" "),_("blockquote",[_("p",[t._v("3xx (重定向)")])]),t._v(" "),_("p",[t._v("304 Not Modified: 资源未修改，可以使用缓存的版本。")]),t._v(" "),_("blockquote",[_("p",[t._v("4xx (客户端错误)")])]),t._v(" "),_("p",[t._v("400 Bad Request: 服务器无法理解请求，因为其格式错误。\n401 Unauthorized: 请求未认证。这意味着用户没有提供凭据或提供的凭据是无效的。\n404 Not Found: 请求的资源在服务器上找不到。")]),t._v(" "),_("blockquote",[_("p",[t._v("5xx (服务器错误)")])]),t._v(" "),_("p",[t._v("500 Internal Server Error: 服务器遇到错误，使其无法完成请求。\n502 Bad Gateway: 作为网关或代理的服务器从上游服务器接收到无效响应。\n504 Gateway Timeout: 作为网关或代理的服务器未及时从上游服务器接收响应。")]),t._v(" "),_("h2",{attrs:{id:"_8-https有什么用-原理是什么-https加密是怎么加密的-https如何保证证书是可信任的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-https有什么用-原理是什么-https加密是怎么加密的-https如何保证证书是可信任的"}},[t._v("#")]),t._v(" 8.https有什么用，原理是什么？https加密是怎么加密的？https如何保证证书是可信任的？")]),t._v(" "),_("h2",{attrs:{id:"_9-http1的缺陷"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-http1的缺陷"}},[t._v("#")]),t._v(" 9.http1的缺陷？")]),t._v(" "),_("ul",[_("li",[t._v("1.高延迟，带来页面加载速度降低。")])]),t._v(" "),_("p",[t._v("网络延迟的原因是队头阻塞，就是前面请求因为某些原因被阻塞了，后面的请求就只能等待了")]),t._v(" "),_("h2",{attrs:{id:"_10-tcp和udp的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-tcp和udp的区别"}},[t._v("#")]),t._v(" 10.tcp和udp的区别？")]),t._v(" "),_("blockquote",[_("p",[t._v("1.tcp是面向连接的，udp是无连接的。")])]),t._v(" "),_("blockquote",[_("p",[t._v("2.tcp更加的可靠，udp不是可靠的。")])]),t._v(" "),_("blockquote",[_("p",[t._v("3.tcp可以保证消息的有序性，而udp不能保证消息的有序性。")])]),t._v(" "),_("blockquote",[_("p",[t._v("4.udp速度比tcp更快，因为它不用建立连接也不用保证消息的有序性。")])]),t._v(" "),_("blockquote",[_("p",[t._v("5.tcp是重量级协议，而udp是轻量级的，因为udp不用建立连接和保证消息的顺序，所以请求头里的元数据会少于tap。")])]),t._v(" "),_("blockquote",[_("p",[t._v("6.tcp头大小大于udp。")])]),t._v(" "),_("blockquote",[_("p",[t._v("7.tcp可以进行流控制，而udp不可以。")])]),t._v(" "),_("h2",{attrs:{id:"_11-osi七层网络模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-osi七层网络模型"}},[t._v("#")]),t._v(" 11.OSI七层网络模型")]),t._v(" "),_("blockquote",[_("p",[t._v("应用层，传输层，数据链路层，网络层。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);