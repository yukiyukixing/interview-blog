<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1.JS</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/interview-blog/favicon.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/interview-blog/assets/css/0.styles.d354ebfa.css" as="style"><link rel="preload" href="/interview-blog/assets/js/app.01bb4500.js" as="script"><link rel="preload" href="/interview-blog/assets/js/2.fe87fc20.js" as="script"><link rel="preload" href="/interview-blog/assets/js/27.9606962d.js" as="script"><link rel="prefetch" href="/interview-blog/assets/js/1.fe06c0c6.js"><link rel="prefetch" href="/interview-blog/assets/js/10.2c4226e7.js"><link rel="prefetch" href="/interview-blog/assets/js/11.35592479.js"><link rel="prefetch" href="/interview-blog/assets/js/12.f900037e.js"><link rel="prefetch" href="/interview-blog/assets/js/13.3b76afac.js"><link rel="prefetch" href="/interview-blog/assets/js/14.6154a0bc.js"><link rel="prefetch" href="/interview-blog/assets/js/15.7508c086.js"><link rel="prefetch" href="/interview-blog/assets/js/16.a6f42578.js"><link rel="prefetch" href="/interview-blog/assets/js/17.1b731afa.js"><link rel="prefetch" href="/interview-blog/assets/js/18.94d03c89.js"><link rel="prefetch" href="/interview-blog/assets/js/19.d9c7290e.js"><link rel="prefetch" href="/interview-blog/assets/js/20.94387ff1.js"><link rel="prefetch" href="/interview-blog/assets/js/21.e1b13055.js"><link rel="prefetch" href="/interview-blog/assets/js/22.13230044.js"><link rel="prefetch" href="/interview-blog/assets/js/23.255013fc.js"><link rel="prefetch" href="/interview-blog/assets/js/24.b0851fb0.js"><link rel="prefetch" href="/interview-blog/assets/js/25.4d97cb3a.js"><link rel="prefetch" href="/interview-blog/assets/js/26.ba26e1e0.js"><link rel="prefetch" href="/interview-blog/assets/js/28.9631c49a.js"><link rel="prefetch" href="/interview-blog/assets/js/29.840b2b3a.js"><link rel="prefetch" href="/interview-blog/assets/js/3.7b480f43.js"><link rel="prefetch" href="/interview-blog/assets/js/30.8c3fece2.js"><link rel="prefetch" href="/interview-blog/assets/js/31.b4917939.js"><link rel="prefetch" href="/interview-blog/assets/js/32.5d3c3c2c.js"><link rel="prefetch" href="/interview-blog/assets/js/33.dfc941d1.js"><link rel="prefetch" href="/interview-blog/assets/js/34.c65814f3.js"><link rel="prefetch" href="/interview-blog/assets/js/35.5a9b30b6.js"><link rel="prefetch" href="/interview-blog/assets/js/36.51659476.js"><link rel="prefetch" href="/interview-blog/assets/js/37.48977777.js"><link rel="prefetch" href="/interview-blog/assets/js/38.999f25b9.js"><link rel="prefetch" href="/interview-blog/assets/js/39.034047f6.js"><link rel="prefetch" href="/interview-blog/assets/js/4.53e8db53.js"><link rel="prefetch" href="/interview-blog/assets/js/40.da4e31c4.js"><link rel="prefetch" href="/interview-blog/assets/js/41.07691d04.js"><link rel="prefetch" href="/interview-blog/assets/js/42.2571b85e.js"><link rel="prefetch" href="/interview-blog/assets/js/5.2eae8d4b.js"><link rel="prefetch" href="/interview-blog/assets/js/6.31f9c63a.js"><link rel="prefetch" href="/interview-blog/assets/js/7.aefd9540.js"><link rel="prefetch" href="/interview-blog/assets/js/vendors~docsearch.bdc2fb18.js">
    <link rel="stylesheet" href="/interview-blog/assets/css/0.styles.d354ebfa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-navbar"><!----> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/interview-blog/" aria-current="page" class="sidebar-link">前言</a></li><li><a href="/interview-blog/大纲.html" class="sidebar-link">大纲</a></li><li><a href="/interview-blog/简历与自我介绍.html" class="sidebar-link">简历与自我介绍</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/interview-blog/基础知识" class="sidebar-heading clickable open"><span>基础知识</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview-blog/base/JS.html" aria-current="page" class="active sidebar-link">1.JS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_1-事件循环-event-loop-⭐" class="sidebar-link">1.事件循环（Event Loop） ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_2-深拷贝-浅拷贝-⭐" class="sidebar-link">2.深拷贝，浅拷贝 ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_3-防抖、节流-⭐" class="sidebar-link">3.防抖、节流 ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_4-原型和原型链-⭐" class="sidebar-link">4.原型和原型链 ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_5-requestanimationframe-⭐" class="sidebar-link">5.requestAnimationFrame ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_6-for-in-和-for-of-的区别-⭐" class="sidebar-link">6.for in 和 for of 的区别 ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_7-箭头函数和普通函数的区别-⭐" class="sidebar-link">7.箭头函数和普通函数的区别？ ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_8-写出new的执行过程-并自己实现一个new函数-⭐" class="sidebar-link">8.写出new的执行过程，并自己实现一个new函数？ ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_9-instanceof" class="sidebar-link">9.instanceof</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_10-promise-⭐" class="sidebar-link">10.Promise ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_11-函数柯里化-⭐" class="sidebar-link">11.函数柯里化 ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_12-设计模式-⭐" class="sidebar-link">12.设计模式 ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_13-实现一个发布订阅系统-⭐" class="sidebar-link">13.实现一个发布订阅系统 ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_14-call-bind-apply-apply和call哪个性能更好" class="sidebar-link">14.call，bind，apply，apply和call哪个性能更好？</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_15-es6有哪些新属性" class="sidebar-link">15.ES6有哪些新属性？</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_16-let、var、const的区别" class="sidebar-link">16.let、var、const的区别</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_17-js数据类型" class="sidebar-link">17.JS数据类型</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_18-map和object的区别" class="sidebar-link">18.Map和Object的区别</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_19-map和set" class="sidebar-link">19.Map和Set</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_20-map和weakmap-weakmap和weakset" class="sidebar-link">20.Map和WeakMap，WeakMap和WeakSet</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_21-weakmap用于哪些场景下" class="sidebar-link">21.WeakMap用于哪些场景下</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_22-重绘、重排的区别" class="sidebar-link">22.重绘、重排的区别？</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_23-export-default和export的区别" class="sidebar-link">23.export default和export的区别？</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_24-闭包" class="sidebar-link">24.闭包</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_25-说一下es6中的proxy" class="sidebar-link">25.说一下ES6中的Proxy？</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_26-js中哪些情况会造成内存泄漏" class="sidebar-link">26.js中哪些情况会造成内存泄漏？</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_27-什么是事件委托和事件冒泡" class="sidebar-link">27.什么是事件委托和事件冒泡</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_28-说一说js数组中的方法" class="sidebar-link">28.说一说JS数组中的方法？</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_29-es-module、commonjs" class="sidebar-link">29.ES Module、CommonJS</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_30-map-和-foreach的区别" class="sidebar-link">30.map 和 forEach的区别</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_31-数组去重-数组对象去重。" class="sidebar-link">31.数组去重，数组对象去重。</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_32-用promise实现一个延时" class="sidebar-link">32.用Promise实现一个延时？</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_33-写一个es5的继承" class="sidebar-link">33.写一个ES5的继承？</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_34-作用域" class="sidebar-link">34.作用域</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/JS.html#_35-js中this的指向" class="sidebar-link">35.JS中this的指向</a></li></ul></li><li><a href="/interview-blog/base/CSS.html" class="sidebar-link">2.CSS</a></li><li><a href="/interview-blog/base/React.html" class="sidebar-link">3.React</a></li><li><a href="/interview-blog/base/3D.html" class="sidebar-link">4.3D</a></li><li><a href="/interview-blog/base/2D.html" class="sidebar-link">5.2D</a></li><li><a href="/interview-blog/base/浏览器.html" class="sidebar-link">6.浏览器</a></li><li><a href="/interview-blog/base/前端工程化.html" class="sidebar-link">7.前端工程化</a></li><li><a href="/interview-blog/base/计算机原理.html" class="sidebar-link">8.计算机原理</a></li><li><a href="/interview-blog/base/微前端.html" class="sidebar-link">9.微前端</a></li><li><a href="/interview-blog/base/算法.html" class="sidebar-link">10.算法</a></li><li><a href="/interview-blog/base/Vue.html" class="sidebar-link">11.Vue</a></li><li><a href="/interview-blog/base/安全.html" class="sidebar-link">12.安全</a></li></ul></section></li><li><a href="/interview-blog/项目.html" class="sidebar-link">项目</a></li><li><a href="/interview-blog/模拟面试.html" class="sidebar-link">模拟面试</a></li><li><a href="/interview-blog/面试实战.html" class="sidebar-link">面试实战</a></li><li><a href="/interview-blog/经验总结.html" class="sidebar-link">经验总结</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_1-js"><a href="#_1-js" class="header-anchor">#</a> 1.JS</h1> <h2 id="_1-事件循环-event-loop-⭐"><a href="#_1-事件循环-event-loop-⭐" class="header-anchor">#</a> 1.事件循环（Event Loop） ⭐</h2> <h3 id="浏览器中的事件循环-event-loop"><a href="#浏览器中的事件循环-event-loop" class="header-anchor">#</a> 浏览器中的事件循环（Event Loop）</h3> <ul><li><p>1.定义：因为JS是单线程执行的，所以它一次只能执行一个任务，如果这个任务时间过长就会造成阻塞，所以JS需要一个异步执行代码的机制，然后就有了事件循环的机制。主线程首先从上到下将JS代码放到执行栈中执行，当执行到异步代码的时候，会将这部分要执行的代码放到异步的任务队列里面，如果是宏任务，就会放到宏任务队列里，如果是微任务，就会放到微任务队列里。当同步代码执行完成后，这时候执行栈为空，js引擎会先查看当前微任务队列里面有没有要执行的任务，如果有的话一个一个的拿出来放到执行栈中执行，执行完看当前宏任务队列里面有没有要执行的任务，有的话也一个一个的拿出来放到执行栈中执行，执行完开始执行下一个宏任务代码。这个过程是循环的，因此称为“事件循环”。</p></li> <li><p>2.宏任务包含哪些</p></li> <li><p>（1）整个script标签里的代码块</p></li> <li><p>（2）setTimeout</p></li> <li><p>（3）setInterval</p></li> <li><p>（4）setImmediate</p></li> <li><p>（5）I/O操作（输入/输出）</p></li> <li><p>（6）UI渲染</p></li> <li><p>3.微任务</p></li> <li><p>（1）Promise.then catch</p></li> <li><p>（2）MutationObserver（监控dom树的变化）</p></li></ul> <h3 id="node中的事件循环"><a href="#node中的事件循环" class="header-anchor">#</a> Node中的事件循环</h3> <ul><li><p>1.Input/Start: 当 Node.js 进程启动时，它会初始化事件循环，然后执行传入的脚本或模块。这个脚本可能会调用一些异步 API，然后进入事件循环等待事件触发。</p></li> <li><p>2.Timers Phase: 在这个阶段，Node.js 检查计划执行的 setTimeout 和 setInterval 回调函数。</p></li> <li><p>3.Pending Callbacks Phase: 在这一阶段，系统处理某些系统操作（如 TCP 错误类型）的回调函数。</p></li> <li><p>4.Idle, Prepare Phase: 用于系统内部操作。</p></li> <li><p>5.Poll Phase: 在这里，Node.js 会检查是否有新的 I/O 事件，执行对应的回调。这个阶段允许新的定时器入队。</p></li> <li><p>6.Check Phase: 在这个阶段，setImmediate() 回调会被执行。</p></li> <li><p>7.Close Callbacks Phase: 如果存在任何 close 事件（例如 socket.on('close', ...)），则在此阶段处理这些回调。</p></li> <li><p>8.事件循环将继续执行，直到回调队列为空，然后退出。需要注意的是，在 Node.js 中，不是所有的任务都通过事件循环进行调度。某些 API，例如 fs 模块，使用了 libuv 的工作线程池来实现文件 I/O。</p></li></ul> <blockquote><p>libuv 是 Node.js 底层的一个关键库，它为 Node.js 提供事件循环和所有的异步行为。</p></blockquote> <blockquote><p><a href="https://mp.weixin.qq.com/s/QgfE5Km1xiEkQqADMLmj-Q" target="_blank" rel="noopener noreferrer">参考资料<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="_2-深拷贝-浅拷贝-⭐"><a href="#_2-深拷贝-浅拷贝-⭐" class="header-anchor">#</a> 2.深拷贝，浅拷贝 ⭐</h2> <ul><li><p>1.深浅拷贝是针对引用类型说的，原始类型不存在深浅拷贝。</p></li> <li><p>2.然后浅拷贝是复制的是对象的引用，而深拷贝是拷贝了一个完全一模一样的对象。</p></li> <li><p>3.浅拷贝的方式：1.Object.assign() 2.展开运算符 3.循环遍历</p></li> <li><p>4.深拷贝的方式：1.JSON.parse(JSON.stringify(obj)) 2.递归 3.lodash中的_.defaultsDeep()方法。</p></li></ul> <blockquote><p>tips: 利用JSON.stringify()的缺陷，处理不了function对象、undefined以及symbol类型，原因是JSON.stringify()在处理这些类型，这些类型会被忽略，不会被处理。并且JSON.stringify()也解决不了循环引用的问题。</p></blockquote> <blockquote><p>深拷贝怎么解决循环引用？</p></blockquote> <p>解决循环引用问题，你通常需要维护一个“已访问”的对象列表。当你试图拷贝一个对象时，你首先检查这个对象是否已经被拷贝过了。如果是，你直接返回之前拷贝过的新对象的引用，不需要重新拷贝它。</p> <div class="language-js extra-class"><pre class="language-js"><code>        <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">quote</span><span class="token operator">:</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
        obj<span class="token punctuation">.</span>quote <span class="token operator">=</span> obj<span class="token punctuation">;</span>
        <span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 基础类型或 null，直接返回</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> obj
            <span class="token punctuation">}</span>
            <span class="token comment">// 检查是否循环引用</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> visited<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 对于数组或对象，创建一个新的空数组或对象</span>
            <span class="token keyword">const</span> copy <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token comment">// 将当前正在拷贝的对象加入已访问列表</span>
            visited<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> copy<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 递归拷贝所有属性</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    copy<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> copy
        <span class="token punctuation">}</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_3-防抖、节流-⭐"><a href="#_3-防抖、节流-⭐" class="header-anchor">#</a> 3.防抖、节流 ⭐</h2> <ul><li>1.防抖：函数被触发n秒之后再执行，如果在这n秒内函数被再次触发，则重新计时。</li></ul> <p>应用场景:</p> <ul><li>搜索框文本输入。当用户停止输入一段时间后，才发送请求进行搜索。</li> <li>窗口调整大小。当用户停止调整窗口大小一段时间后，才重新计算布局。(注：这个场景根据需求来，使用防抖和节流理论上都是可以的，看你的需求是什么。)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>2.节流：节流确保一个函数在指定的时间间隔内只执行一次，即使在这段时间内触发多次。</li></ul> <p>应用场景:</p> <ul><li>滚动事件。例如，在用户滚动时定期检查页面的位置，而不是每次滚动都检查。</li> <li>窗口调整大小。间隔一段时间更新一次，让你在调整的过程中能看到布局的变化。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> lastCall <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> lastCall <span class="token operator">&gt;=</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            lastCall <span class="token operator">=</span> now
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_4-原型和原型链-⭐"><a href="#_4-原型和原型链-⭐" class="header-anchor">#</a> 4.原型和原型链 ⭐</h2> <ul><li>1.原型的定义：每一个JS对象（除了null）在创建的时候都会与之关联另一个对象，这个对象就是我们所说的原型。每一个对象都可以从原型继承属性。</li></ul> <blockquote><p>tips：每个函数都有一个prototype属性，每个对象都有一个__proto__属性。</p></blockquote> <ul><li><p>2.原型链定义：当你试图访问一个对象的属性时，JS会首先在对象本身查找，如果没有找到，则会继续在该对象的原型上查找，然后是原型的原型，以此类推。这种由原型链接到原型的系列对象被称为原型链。</p></li> <li><p>3.作用：</p></li> <li><p>属性查找，当视图访问一个对象的属性时，如果对象本身没有这个属性，那么js就会去这个对象的原型上去找，一直找到这条原型链的终点null。</p></li> <li><p>继承：原型链允许一个对象继承另一个对象的属性和方法。</p></li></ul> <h2 id="_5-requestanimationframe-⭐"><a href="#_5-requestanimationframe-⭐" class="header-anchor">#</a> 5.requestAnimationFrame ⭐</h2> <ul><li><p>1.作用：requestAnimationFrame告诉浏览器你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。</p></li> <li><p>2.性能：</p></li></ul> <p>（1）因为requestAnimationFrame的执行时机是在每次重绘之前，所以会减少不必要的帧和重绘，并且它也会尽量的跟浏览器的刷新率同步，通常是60帧/秒。</p> <p>（2）当页面标签切换后或页面不可见时，requestAnimationFrame会被暂停，以提升性能。</p> <h2 id="_6-for-in-和-for-of-的区别-⭐"><a href="#_6-for-in-和-for-of-的区别-⭐" class="header-anchor">#</a> 6.for in 和 for of 的区别 ⭐</h2> <ul><li><p>1.for...in遍历的是key，而for...of遍历的是value</p></li> <li><p>2.for...in可以遍历普通对象，而for...of只能遍历可迭代类型对象</p></li> <li><p>3.for...in遍历对象的时候会遍历对象原型链上面的属性。</p></li> <li><p>4.for...in一般被用来遍历对象，for...of一般被用来遍历数组。</p></li></ul> <blockquote><p>tips：hasOwnProperty()方法可以判断属性是否是属于对象本身，属于的话为true，不属于为false。</p></blockquote> <h2 id="_7-箭头函数和普通函数的区别-⭐"><a href="#_7-箭头函数和普通函数的区别-⭐" class="header-anchor">#</a> 7.箭头函数和普通函数的区别？ ⭐</h2> <ul><li><p>1.箭头函数没有自己的this，this来自于执行上下文。</p></li> <li><p>2.箭头函数不能用作构造函数，所以它也没有prototype。</p></li> <li><p>3.箭头函数没有arguments，不能使用arguments取函数的参数。</p></li></ul> <h2 id="_8-写出new的执行过程-并自己实现一个new函数-⭐"><a href="#_8-写出new的执行过程-并自己实现一个new函数-⭐" class="header-anchor">#</a> 8.写出new的执行过程，并自己实现一个new函数？ ⭐</h2> <ul><li>定义：new运算符可以用来创建一个新的对象实例。</li></ul> <blockquote><p>new关键字的执行过程：</p></blockquote> <ul><li><p>1.创建一个空的JS对象（即{}）</p></li> <li><p>2.将新创建的对象的原型链接到构造函数的原型，确保新对象可以继承构造函数原型上的方法和属性</p></li> <li><p>3.将新创建的对象作为this的上下文</p></li> <li><p>4.如果该函数没有返回对象，则返回新创建的对象</p></li></ul> <blockquote><p>手写一个new：</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> fn<span class="token punctuation">.</span>prototype
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token keyword">return</span> res <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> res <span class="token operator">:</span> obj
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_9-instanceof"><a href="#_9-instanceof" class="header-anchor">#</a> 9.instanceof</h2> <blockquote><p>instanceof运算符用来检测某个构造函数的原型是否在某个对象实例的原型链上。</p></blockquote> <blockquote><p>手写一个instanceof？</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">leftObj<span class="token punctuation">,</span> rightFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> left <span class="token operator">=</span> leftObj<span class="token punctuation">.</span>__proto__
    <span class="token keyword">const</span> right <span class="token operator">=</span> rightFn<span class="token punctuation">.</span>prototype
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
        left <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_10-promise-⭐"><a href="#_10-promise-⭐" class="header-anchor">#</a> 10.Promise ⭐</h2> <p>（1）状态：大致分为三种状态。</p> <p>①：pending：待定</p> <p>②、fullfilled：已实现</p> <p>③、rejected：已拒绝</p> <p>3、解决了什么问题？</p> <p>①、支持链式调用，解决了回调地狱的问题。</p> <p>（2）手写一个Promise.all ⭐</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">promiseAll</span><span class="token punctuation">(</span><span class="token parameter">promiseArr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">let</span> completed <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">const</span> len <span class="token operator">=</span> promiseArr<span class="token punctuation">.</span>length
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promiseArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">val</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> val
                completed<span class="token operator">++</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>completed <span class="token operator">===</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>（3）手写一个Promise.race</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">promiseRace</span><span class="token punctuation">(</span><span class="token parameter">promiseArr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resovle<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> len <span class="token operator">=</span> promiseArr<span class="token punctuation">.</span>length
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> promiseItem <span class="token keyword">of</span> promiseArr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promiseItem<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resovle<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_11-函数柯里化-⭐"><a href="#_11-函数柯里化-⭐" class="header-anchor">#</a> 11.函数柯里化 ⭐</h2> <blockquote><p>将多个参数的一个函数转换成使用一系列一个参数的函数。</p></blockquote> <blockquote><p>也就是将fn(1,2,3,4)转换成fn(1)(2)(3)(4)</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">curryFn</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> fn<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>newArgs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">curryFn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>newArgs<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>柯里化的好处：延迟执行，提前返回。</p></blockquote> <h2 id="_12-设计模式-⭐"><a href="#_12-设计模式-⭐" class="header-anchor">#</a> 12.设计模式 ⭐</h2> <ul><li>1.单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Singleton<span class="token punctuation">.</span>instacne<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Singleton<span class="token punctuation">.</span>instacne <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>instacne
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>2.观察者模式：也被称为发布/订阅模式。在这种模式中，一个对象（发布者）维护一系列依赖于它的对象（观察者），并在任何状态更改时自动通知它们。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>listeners <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>

    <span class="token function">on</span><span class="token punctuation">(</span><span class="token parameter">listener</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">emit</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">listener</span> <span class="token operator">=&gt;</span> <span class="token function">listener</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> obs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obs<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Listener 1: &quot;</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obs<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Listener 2: &quot;</span> <span class="token operator">+</span> data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obs<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>3.工厂模式：这种模式用于创建对象，让子类决定实例化哪一个类。它提供了一个创建对象的接口，但允许子类更改将要实例化的类。</p></li> <li><p>4.原型模式：JS是基于原型的语言，所以这种模式在语言核心中已经内建。它允许你复制或克隆对象，而不是每次都从零开始创建。</p></li></ul> <h2 id="_13-实现一个发布订阅系统-⭐"><a href="#_13-实现一个发布订阅系统-⭐" class="header-anchor">#</a> 13.实现一个发布订阅系统 ⭐</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">EventBus</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subscribes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>subscribes<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>subscribes<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subscribes<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>subscribes<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscribes<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subscribes<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">publish</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subscribes<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">item</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> eventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">收到的数据为：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
eventBus<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
eventBus<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> <span class="token string">'Hello'</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_14-call-bind-apply-apply和call哪个性能更好"><a href="#_14-call-bind-apply-apply和call哪个性能更好" class="header-anchor">#</a> 14.call，bind，apply，apply和call哪个性能更好？</h2> <ul><li><p>1.call、apply、bind都可以改变函数内部this的指向。</p></li> <li><p>2.bind返回的是一个函数，call和apply返回的是值。</p></li> <li><p>3.bind和call的第二参数都是接收的一个参数列表，而apply的第二个参数接收的是一个数组。</p></li> <li><p>4.call的性能比apply的性能更好。</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1.手写bind</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj <span class="token operator">=</span> window<span class="token punctuation">,</span> <span class="token operator">...</span>args1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> that <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">that</span><span class="token punctuation">(</span><span class="token operator">...</span>args1<span class="token punctuation">,</span> <span class="token operator">...</span>args2<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">that</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>args1<span class="token punctuation">,</span> <span class="token operator">...</span>args2<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 手写call</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj <span class="token operator">=</span> window<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> obj<span class="token punctuation">.</span>fn
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 手写apply</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj <span class="token operator">=</span> window<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> obj<span class="token punctuation">.</span>fn
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_15-es6有哪些新属性"><a href="#_15-es6有哪些新属性" class="header-anchor">#</a> 15.ES6有哪些新属性？</h2> <ul><li><p>1.let和const</p></li> <li><p>2.Promise</p></li> <li><p>3.for...of</p></li> <li><p>4.展开语法和对象数组解构</p></li> <li><p>5.箭头函数</p></li> <li><p>6.函数传默认参数</p></li> <li><p>7.Map，Set，WeakMap，WeakSet</p></li> <li><p>8.类</p></li> <li><p>9.模板字符串</p></li> <li><p>10.Proxy</p></li></ul> <h2 id="_16-let、var、const的区别"><a href="#_16-let、var、const的区别" class="header-anchor">#</a> 16.let、var、const的区别</h2> <p>1.let不能重复定义变量，而var可以</p> <p>2.var存在变量提升，可在声明前使用变量，而let由于存在暂时性死区不能在声明变量前使用</p> <p>3.var声明的变量会挂载到window下面，而let不会挂到window下面，而是形成一个块级作用域。</p> <p>4.const定义的是常量，定义之后就不可更改，而且初始化的时候必须赋值，其他和let一样。</p> <h2 id="_17-js数据类型"><a href="#_17-js数据类型" class="header-anchor">#</a> 17.JS数据类型</h2> <ul><li><p>1.原始类型：number、boolean、null、undefined、string、Symbol、BigInt</p></li> <li><p>2.引用类型：Object</p></li></ul> <h2 id="_18-map和object的区别"><a href="#_18-map和object的区别" class="header-anchor">#</a> 18.Map和Object的区别</h2> <p>Map：</p> <ul><li>键可以是任何类型</li> <li>有序集合（按插入顺序排序）</li> <li>内置方法（如 <code>get</code>、<code>set</code>、<code>has</code>、<code>delete</code>）</li> <li>可以轻易地获取大小（<code>.size</code>）</li></ul> <p>Object：</p> <ul><li>键必须是String或Symbol（虽然可以看起来是其他类型，但实际上会被转化为字符串）</li> <li>无序集合</li> <li>没有内置方法来获取大小</li> <li>更适用于作为记录（record）或者字典（dictionary）</li></ul> <blockquote><p>什么情况下用Map，什么情况下用Object？</p></blockquote> <ul><li><p>1.增删性能：如果代码涉及到大量插入操作，那么显然Map的性能更佳，同样，如果代码涉及到大量的删除操作，也是Map的性能更佳。</p></li> <li><p>2.查找操作，如果代码涉及到大量的查找操作，那么可能Object性能会更优一点。</p></li></ul> <h2 id="_19-map和set"><a href="#_19-map和set" class="header-anchor">#</a> 19.Map和Set</h2> <ul><li><p>Map: 存储键-值对。键可以是任何类型（包括对象、函数等）。</p></li> <li><p>Set: 存储唯一值，不允许重复。值可以是任何类型。</p></li></ul> <h2 id="_20-map和weakmap-weakmap和weakset"><a href="#_20-map和weakmap-weakmap和weakset" class="header-anchor">#</a> 20.Map和WeakMap，WeakMap和WeakSet</h2> <p>Map:</p> <ul><li>键可以是任何类型</li> <li>键和值都可以被枚举</li> <li>强引用键，即使你删除了对键的引用，它也不会被垃圾回收</li></ul> <p>WeakMap:</p> <ul><li>键必须是对象</li> <li>键和值都不可枚举</li> <li>弱引用键，如果你删除了对键的引用，它就会被垃圾回收</li></ul> <p>WeakMap: 存储键-值对，键必须是对象。</p> <p>WeakSet: 存储唯一对象值。</p> <h2 id="_21-weakmap用于哪些场景下"><a href="#_21-weakmap用于哪些场景下" class="header-anchor">#</a> 21.WeakMap用于哪些场景下</h2> <ul><li>1.缓存和记忆化：WeakMap 可用于缓存已经计算过的结果，以便将来快速检索。由于它是弱引用的，所以当对象不再需要时，它们可以被垃圾收集。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>        <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">function</span> <span class="token function">expensiveOperation</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token comment">/* perform expensive calculation（执行昂贵的计算） */</span>
            cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><ul><li>2.关联额外数据：当你想给一个对象（比如网页上的一个按钮或图像）添加一些额外信息，但又不想直接改变这个对象，那么可以用 WeakMap。这样做的好处是，当这个对象不再需要时，它和你添加的额外信息都会自动被清除，不会占用多余的内存。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>        <span class="token keyword">const</span> domData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 在某个 DOM 元素上设置数据</span>
        domData<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myDiv'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">clicks</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 在事件监听器中更新或读取数据</span>
        document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> data <span class="token operator">=</span> domData<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                data<span class="token punctuation">.</span>clicks<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_22-重绘、重排的区别"><a href="#_22-重绘、重排的区别" class="header-anchor">#</a> 22.重绘、重排的区别？</h2> <ul><li><p>1.重绘不会导致页面重新渲染。</p></li> <li><p>2.回流(重排)会导致页面重新渲染。</p></li></ul> <blockquote><p>哪些操作会导致重绘操作？哪些操作会导致回流（重排）操作？</p></blockquote> <ul><li><p>1.会导致重绘的操作，color，background，visibility等这些属性的改变会导致重绘。</p></li> <li><p>2.导致重排的操作，添加/删除可见的dom元素，改变元素位置，改变浏览器窗口尺寸等等，display，padding，margin，postion等等。</p></li> <li><p>3.重排优化：</p></li></ul> <p>1.不要频繁操作样式。</p> <p>2.使用absolute和fixed脱离正常文档流</p> <p>3.优化动画，可以把动画加在使用absolute和fixed的元素上。</p> <h2 id="_23-export-default和export的区别"><a href="#_23-export-default和export的区别" class="header-anchor">#</a> 23.export default和export的区别？</h2> <ul><li><p>1.export可以直接导出表达式，而export default不行。</p></li> <li><p>2.export导出的，在导入的时候需要加入{}进行导入，而export default则不需要。</p></li> <li><p>3.在一个文件模块中，export可以有多个，而export default只有一个。</p></li></ul> <h2 id="_24-闭包"><a href="#_24-闭包" class="header-anchor">#</a> 24.闭包</h2> <ul><li><p>1.定义：函数和与其相关的引用环境的组合就是闭包。</p></li> <li><p>2.创建：当一个内部函数在一个外部函数里被定义，并且内部函数引用了外部函数的变量或参数，那么闭包就被创建了。</p></li> <li><p>3.不会被垃圾回收：在外部函数执行完毕之后，内部函数中引用的变量或参数不会被回收。</p></li> <li><p>4.闭包的作用：</p></li> <li><p>数据封装和私有变量：闭包可以用来模拟私有变量，提供公开的API而隐藏内部实现细节。</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 私有变量</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">increment</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      count<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">decrement</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      count<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">getCount</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个新的计数器</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 0，通过API获取count的值</span>
counter<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过API增加count</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 1</span>
counter<span class="token punctuation">.</span><span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过API减少count</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 0</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 undefined，因为count是私有变量，无法直接访问</span>
</code></pre></div><blockquote><p>在这个例子中，createCounter 函数返回一个包含三个方法的对象（increment, decrement, 和 getCount）。这些方法都有权访问createCounter 的局部变量count，但是从外部是无法直接访问 count 的。这样，count 就成了一个私有变量，只能通过提供的API来进行操作。</p></blockquote> <blockquote><p>这种方式提供了一种封装内部实现细节的机制，你可以自由地改变内部的实现而不影响到外部代码，增加了代码的可维护性和安全性。</p></blockquote> <ul><li>动态生成函数：根据不同的参数或条件生成具有特定行为的函数。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token parameter">language</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>language <span class="token operator">===</span> <span class="token string">'English'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>language <span class="token operator">===</span> <span class="token string">'Spanish'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hola, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>language <span class="token operator">===</span> <span class="token string">'Chinese'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">你好, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">！</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> greetInEnglish <span class="token operator">=</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token string">'English'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> greetInSpanish <span class="token operator">=</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token string">'Spanish'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> greetInChinese <span class="token operator">=</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token string">'Chinese'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">greetInEnglish</span><span class="token punctuation">(</span><span class="token string">'John'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 &quot;Hello, John!&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">greetInSpanish</span><span class="token punctuation">(</span><span class="token string">'Juan'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 &quot;Hola, Juan!&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">greetInChinese</span><span class="token punctuation">(</span><span class="token string">'张三'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 &quot;你好, 张三！&quot;</span>
</code></pre></div><blockquote><p>在这个例子中，greeting 函数接收一个language 参数，并返回一个新的函数。这个新函数根据传入的language 参数来决定如何生成问候语。</p></blockquote> <blockquote><p>返回的函数（闭包）有权访问greeting 函数的language 参数，即使greeting 函数的执行上下文已经被销毁。这就是闭包的魔力所在。</p></blockquote> <blockquote><p>通过这样的方式，你可以创建一个非常灵活和可配置的函数，用于处理各种不同的场景和需求。</p></blockquote> <ul><li>函数柯里化：使用闭包逐步传递少量参数。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 普通的加法函数</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 柯里化的加法函数</span>
<span class="token keyword">function</span> <span class="token function">curriedAdd</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用</span>
<span class="token keyword">const</span> addFive <span class="token operator">=</span> <span class="token function">curriedAdd</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此时，addFive 是一个闭包，保存了 a 的值为 5</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">addFive</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 8（5 + 3）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">addFive</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 9（5 + 4）</span>
</code></pre></div><blockquote><p>在上面的例子中，curriedAdd 函数接受一个参数 a，然后返回一个新的函数，这个新函数期望接受第二个参数 b。这里就产生了一个闭包，因为返回的函数能够“记住”第一个参数 a。</p></blockquote> <blockquote><p>通过使用闭包和柯里化，你可以编写更灵活、更可复用的代码。这也是函数式编程中的一种常见模式。</p></blockquote> <ul><li><p>5.注意事项：</p></li> <li><p>闭包使用不当会导致内存泄漏</p></li> <li><p>过度使用闭包会导致代码难以理解和维护</p></li></ul> <h2 id="_25-说一下es6中的proxy"><a href="#_25-说一下es6中的proxy" class="header-anchor">#</a> 25.说一下ES6中的Proxy？</h2> <blockquote><p>Proxy对象用于创建一个对象的代理，从而实现基本的拦截和自定义（属性查找，赋值，枚举，函数调用等）。</p></blockquote> <blockquote><p>语法：</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>参数：target：要使用Proxy包装的目标对象。handler：一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行操作时代理p的行为。</p></blockquote> <blockquote><p>Proxy本质上是一个构造函数。</p></blockquote> <blockquote><p>Proxy.revocable()用来创建一个可撤销的Proxy对象，撤销方法revoke()。</p></blockquote> <blockquote><p>Proxy作用：用于拦截和自定义对象的一些操作。</p></blockquote> <ul><li>总结：Proxy对象用于创建一个对象的代理，从而实现对对象的一些操作，例如拦截和自定义。Vue3中就使用了Proxy代替了Vue2中的Object.defineProperty。</li></ul> <h2 id="_26-js中哪些情况会造成内存泄漏"><a href="#_26-js中哪些情况会造成内存泄漏" class="header-anchor">#</a> 26.js中哪些情况会造成内存泄漏？</h2> <p>1.闭包使用不当可能会导致内存泄漏。</p> <p>2.Dom对象内存泄漏。</p> <p>3.使用setTimeout和setInterval没有及时销毁。</p> <p>4.隐式声明的全局变量。</p> <h2 id="_27-什么是事件委托和事件冒泡"><a href="#_27-什么是事件委托和事件冒泡" class="header-anchor">#</a> 27.什么是事件委托和事件冒泡</h2> <p>事件冒泡：在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。</p> <p>事件委托：就是利用冒泡的原理，把事件加到父级上，通过判断事件来源的子集，执行相应的操作，事件委托首先可以极大减少事件绑定次数，提高性能；其次可以让新加入的子元素也可以拥有相同的操作。</p> <h2 id="_28-说一说js数组中的方法"><a href="#_28-说一说js数组中的方法" class="header-anchor">#</a> 28.说一说JS数组中的方法？</h2> <blockquote><p>总共31个。</p></blockquote> <ul><li><p>1.增删：push()、pop()、shift()、unshift()</p></li> <li><p>2.遍历：forEach()、reduce()、reduceRight()、some()、every()、filter()、map()</p></li> <li><p>3.查：indexOf()、lastIndexOf()、includes()、find()、findIndex()</p></li> <li><p>4.排序：sort()、reverse()</p></li> <li><p>5.合并：concat()、join()</p></li> <li><p>6.拆分：splice()、slice()</p></li> <li><p>7.填充：fill()、copyWithin()</p></li> <li><p>8.迭代：keys()、values()、entries()</p></li> <li><p>9.转换方法：toString()、toLoacaleString()</p></li> <li><p>10.扁平化方法：flat()、flatMap()</p></li></ul> <h2 id="_29-es-module、commonjs"><a href="#_29-es-module、commonjs" class="header-anchor">#</a> 29.ES Module、CommonJS</h2> <ul><li><p>1.语法：CommonJS 使用 <code>require</code> 和 <code>module.exports</code>，而 ESM 使用 <code>import</code> 和 <code>export</code>。</p></li> <li><p>2.运行时 vs 编译时：CommonJS 是运行时执行，而 ESM 是编译时执行。</p></li> <li><p>3.动态 vs 静态：CommonJS 可以动态加载模块，而 ESM 是静态的。</p></li> <li><p>4.适用场景：CommonJS 主要用于服务器端（Node.js），而 ESM 主要用于浏览器，但现在 Node.js 也越来越支持 ESM。</p></li></ul> <h2 id="_30-map-和-foreach的区别"><a href="#_30-map-和-foreach的区别" class="header-anchor">#</a> 30.map 和 forEach的区别</h2> <ul><li>1.map返回一个新数组，forEach不返回任何值。</li></ul> <h2 id="_31-数组去重-数组对象去重。"><a href="#_31-数组去重-数组对象去重。" class="header-anchor">#</a> 31.数组去重，数组对象去重。</h2> <blockquote><p>1.new Set()</p></blockquote> <blockquote><p>2.双循环。</p></blockquote> <blockquote><p>3.利用indexOf。</p></blockquote> <blockquote><p>采用fiter，map，reduce等方法。</p></blockquote> <h2 id="_32-用promise实现一个延时"><a href="#_32-用promise实现一个延时" class="header-anchor">#</a> 32.用Promise实现一个延时？</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">time</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3秒后触发'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_33-写一个es5的继承"><a href="#_33-写一个es5的继承" class="header-anchor">#</a> 33.写一个ES5的继承？</h2> <div class="language-js extra-class"><pre class="language-js"><code>        <span class="token comment">// 1.原型链继承</span>
        <span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
        <span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
        <span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>缺点：引用类型所有属性被实例共享。</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code>        <span class="token comment">// 2.盗用构造函数继承</span>
        <span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
        <span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code>        <span class="token comment">// 3.组合继承</span>
        <span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
        <span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>融合了上面2种模式的优点，是JS种最常用的继承方式。</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code>        <span class="token comment">// 4.原型式继承</span>
        <span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
            <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>所有实例会共享引用类型属性</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code>        <span class="token comment">// 5.寄生式继承</span>
        <span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
            clone<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'小王'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> clone<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>缺点：每次创建实例的时候，方法都会被重新创建一遍。</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code>        <span class="token comment">// 6.寄生式组合继承</span>
        <span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> prototype <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
            prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> <span class="token constant">B</span><span class="token punctuation">;</span>
            <span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
        <span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>引用类型最佳的继承范式</p></blockquote> <h2 id="_34-作用域"><a href="#_34-作用域" class="header-anchor">#</a> 34.作用域</h2> <blockquote><p>什么是作用域？作用域就是变量，函数可访问的范围。</p></blockquote> <blockquote><p>什么是作用域链？js引擎在运行的时候，查找变量的时候会从当前执行作用域逐级向外查找，形成一条链状结构，就是作用域链。</p></blockquote> <blockquote><p>切换作用域是消耗性能的。</p></blockquote> <h2 id="_35-js中this的指向"><a href="#_35-js中this的指向" class="header-anchor">#</a> 35.JS中this的指向</h2> <p>1.一般情况下，this是指向调用者。如果在全局调用那就是指向window。</p> <p>2.使用new的时候，this指向创建的对象。</p> <p>3.箭头函数中的this来自于上下文。</p> <p>4.在使用call和apply以及bind的时候绑定到指定的对象。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/interview-blog/简历与自我介绍.html" class="prev">
        简历与自我介绍
      </a></span> <span class="next"><a href="/interview-blog/base/CSS.html">
        2.CSS
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/interview-blog/assets/js/app.01bb4500.js" defer></script><script src="/interview-blog/assets/js/2.fe87fc20.js" defer></script><script src="/interview-blog/assets/js/27.9606962d.js" defer></script>
  </body>
</html>
