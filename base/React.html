<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>3.React</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/interview-blog/favicon.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/interview-blog/assets/css/0.styles.d354ebfa.css" as="style"><link rel="preload" href="/interview-blog/assets/js/app.e3b64c75.js" as="script"><link rel="preload" href="/interview-blog/assets/js/2.fe87fc20.js" as="script"><link rel="preload" href="/interview-blog/assets/js/23.048d7387.js" as="script"><link rel="prefetch" href="/interview-blog/assets/js/1.fe06c0c6.js"><link rel="prefetch" href="/interview-blog/assets/js/10.2c4226e7.js"><link rel="prefetch" href="/interview-blog/assets/js/11.35592479.js"><link rel="prefetch" href="/interview-blog/assets/js/12.f900037e.js"><link rel="prefetch" href="/interview-blog/assets/js/13.3b76afac.js"><link rel="prefetch" href="/interview-blog/assets/js/14.6154a0bc.js"><link rel="prefetch" href="/interview-blog/assets/js/15.7508c086.js"><link rel="prefetch" href="/interview-blog/assets/js/16.a6f42578.js"><link rel="prefetch" href="/interview-blog/assets/js/17.1b731afa.js"><link rel="prefetch" href="/interview-blog/assets/js/18.94d03c89.js"><link rel="prefetch" href="/interview-blog/assets/js/19.d9c7290e.js"><link rel="prefetch" href="/interview-blog/assets/js/20.94387ff1.js"><link rel="prefetch" href="/interview-blog/assets/js/21.e1b13055.js"><link rel="prefetch" href="/interview-blog/assets/js/22.2fae3f61.js"><link rel="prefetch" href="/interview-blog/assets/js/24.08022b71.js"><link rel="prefetch" href="/interview-blog/assets/js/25.7199f506.js"><link rel="prefetch" href="/interview-blog/assets/js/26.4501a70f.js"><link rel="prefetch" href="/interview-blog/assets/js/27.efc7e089.js"><link rel="prefetch" href="/interview-blog/assets/js/28.106fe877.js"><link rel="prefetch" href="/interview-blog/assets/js/29.0469e555.js"><link rel="prefetch" href="/interview-blog/assets/js/3.7b480f43.js"><link rel="prefetch" href="/interview-blog/assets/js/30.56cef343.js"><link rel="prefetch" href="/interview-blog/assets/js/31.f375aecb.js"><link rel="prefetch" href="/interview-blog/assets/js/32.0bac3daa.js"><link rel="prefetch" href="/interview-blog/assets/js/33.f759628b.js"><link rel="prefetch" href="/interview-blog/assets/js/34.42b00096.js"><link rel="prefetch" href="/interview-blog/assets/js/35.59c79fb4.js"><link rel="prefetch" href="/interview-blog/assets/js/36.31c53018.js"><link rel="prefetch" href="/interview-blog/assets/js/37.9c6aa256.js"><link rel="prefetch" href="/interview-blog/assets/js/38.7055e9dc.js"><link rel="prefetch" href="/interview-blog/assets/js/39.96b3d349.js"><link rel="prefetch" href="/interview-blog/assets/js/4.53e8db53.js"><link rel="prefetch" href="/interview-blog/assets/js/40.aeb0e367.js"><link rel="prefetch" href="/interview-blog/assets/js/5.2eae8d4b.js"><link rel="prefetch" href="/interview-blog/assets/js/6.31f9c63a.js"><link rel="prefetch" href="/interview-blog/assets/js/7.aefd9540.js"><link rel="prefetch" href="/interview-blog/assets/js/vendors~docsearch.bdc2fb18.js">
    <link rel="stylesheet" href="/interview-blog/assets/css/0.styles.d354ebfa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-navbar"><!----> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/interview-blog/" aria-current="page" class="sidebar-link">前言</a></li><li><a href="/interview-blog/简历与自我介绍.html" class="sidebar-link">简历与自我介绍</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/interview-blog/基础知识" class="sidebar-heading clickable open"><span>基础知识</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview-blog/base/JS.html" class="sidebar-link">1.JS</a></li><li><a href="/interview-blog/base/CSS.html" class="sidebar-link">2.CSS</a></li><li><a href="/interview-blog/base/React.html" aria-current="page" class="active sidebar-link">3.React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_1-react的fiber架构-⭐" class="sidebar-link">1.React的fiber架构 ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_2-react虚拟dom" class="sidebar-link">2.React虚拟dom</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_3-react中的diff算法-⭐" class="sidebar-link">3.React中的diff算法 ⭐</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_4-react的状态管理库redux" class="sidebar-link">4.React的状态管理库Redux</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_5-react中的hooks" class="sidebar-link">5.React中的hooks</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_6-react-hooks和高阶组件差别" class="sidebar-link">6.React hooks和高阶组件差别</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_7-useeffect要注意的地方" class="sidebar-link">7.useEffect要注意的地方</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_8-usememo-usecallback差别" class="sidebar-link">8.useMemo，useCallback差别</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_9-react-的主要特点是什么" class="sidebar-link">9.React 的主要特点是什么?</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_10-react-生命周期" class="sidebar-link">10.React 生命周期</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_11-react-中-refs-的作用是什么" class="sidebar-link">11.React 中 refs 的作用是什么？</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_12-说一下react中的类组件和函数式组件" class="sidebar-link">12.说一下React中的类组件和函数式组件</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_13-什么是高阶组件" class="sidebar-link">13.什么是高阶组件</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_14-什么是受控组件" class="sidebar-link">14.什么是受控组件</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_15-说一下react-中的-props" class="sidebar-link">15.说一下React 中的 props?</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_16-状态和属性有什么区别" class="sidebar-link">16.状态和属性有什么区别?</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_17-在组件库中当使用-forward-refs-时-你需要额外的注意" class="sidebar-link">17.在组件库中当使用 forward refs 时，你需要额外的注意?</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_18-react-多个setstate会触发几次render" class="sidebar-link">18.react 多个setState会触发几次render</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_19-setstate执行机制" class="sidebar-link">19.setState执行机制?</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_20-react-router工作原理" class="sidebar-link">20.React-Router工作原理</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_21-react和vue的区别" class="sidebar-link">21.React和Vue的区别</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_22-react18有哪些升级" class="sidebar-link">22.React18有哪些升级</a></li><li class="sidebar-sub-header"><a href="/interview-blog/base/React.html#_23-react的渲染过程" class="sidebar-link">23.React的渲染过程</a></li></ul></li><li><a href="/interview-blog/base/前端工程化.html" class="sidebar-link">4.前端工程化</a></li><li><a href="/interview-blog/base/浏览器.html" class="sidebar-link">5.浏览器</a></li><li><a href="/interview-blog/base/计算机原理.html" class="sidebar-link">6.计算机原理</a></li><li><a href="/interview-blog/base/微前端.html" class="sidebar-link">7.微前端</a></li><li><a href="/interview-blog/base/3D.html" class="sidebar-link">8.3D</a></li><li><a href="/interview-blog/base/2D.html" class="sidebar-link">9.2D</a></li><li><a href="/interview-blog/base/算法.html" class="sidebar-link">10.算法</a></li></ul></section></li><li><a href="/interview-blog/项目.html" class="sidebar-link">项目</a></li><li><a href="/interview-blog/模拟面试.html" class="sidebar-link">模拟面试</a></li><li><a href="/interview-blog/面试实战.html" class="sidebar-link">面试实战</a></li><li><a href="/interview-blog/经验总结.html" class="sidebar-link">经验总结</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_3-react"><a href="#_3-react" class="header-anchor">#</a> 3.React</h1> <h2 id="_1-react的fiber架构-⭐"><a href="#_1-react的fiber架构-⭐" class="header-anchor">#</a> 1.React的fiber架构 ⭐</h2> <ul><li><p>1.requestIdleCallback：在浏览器空闲时间被调用，有两个参数，第一个是回调函数，第二个是timeout，在timeout毫秒后没被调用，那么将加入事件循环中排队。</p></li> <li><p>2.react16之前的stack架构实现虚拟dom转成真实dom，是采用循环递归的方式，这个过程是不可中断的，如果你的虚拟dom树很大的话，那页面就得等待，主线程一直被占用，而且这个过程不可被打断。</p></li> <li><p>3.浏览器一帧里面会做哪些工作？</p></li></ul> <blockquote><p>标准屏幕刷新率下面（1秒60帧），那么每帧也就是16.6ms</p></blockquote> <p>浏览器在一帧里面会依次执行：</p> <p>输入事件（阻塞输入事件，非阻塞输入事件） =&gt; 定时器 =&gt; 开始帧 =&gt; requestAnimationFrame =&gt; 计算样式，更新布局，布局 =&gt; 绘制 =&gt; 空闲阶段</p> <p><img src="/interview-blog/assets/img/js.5aba1a3f.png" alt="JS.png"></p> <ul><li>4.react fiber架构，fiber架构本质上是一种数据结构，其实是棵树。然后fiber做的事情就是将虚拟dom转成fiber结构，转的过程中知道哪些dom是更新了的，并打上对应的变更标签，然后这个转的过程是可以中断的，因为它是通过链表去处理这颗树的，每个fiber节点有父节点，兄弟节点以及子节点，所以可以中断，然后关键的点是每个节点的更新可以分配到浏览器每帧的空闲时间里，这里有一个函数，requestIdleCallback，这个函数可以让任务在每帧的空闲时间执行，当然react实现的时候用的不是这个函数，而是自己模拟了一个拥有requestIdleCallback这样功能的函数，因为requestIdleCallback只能在谷歌浏览器下面运行，不兼容老的其他的浏览器，所以react自己模拟了一个。然后fiber架构分为两个阶段，一个协调阶段，也就是将虚拟dom转成fiber数据结构，这个阶段是可以中断的，然后第二个是提交阶段，将fiber数据结构转成真实的dom,这个阶段是不可以中断的，因为协调阶段已经将要增删改的dom都算好了，所以提交阶段就会很快。</li></ul> <h2 id="_2-react虚拟dom"><a href="#_2-react虚拟dom" class="header-anchor">#</a> 2.React虚拟dom</h2> <p>虚拟 DOM 本质上是一个 JS 对象，它反映了真实 DOM 的结构和内容。</p> <ul><li><p>1.提供一个中间缓存，使得直接操作实际的 DOM（这通常是昂贵的操作）不再那么频繁。</p></li> <li><p>2.通过对比新旧虚拟 DOM 来计算出最小的变动，从而优化实际 DOM 的更新。</p></li></ul> <p>虚拟dom可以让react更优雅高效的更新真实dom，虚拟dom可以让开发者不用关注dom操作，只操作数据。</p> <h2 id="_3-react中的diff算法-⭐"><a href="#_3-react中的diff算法-⭐" class="header-anchor">#</a> 3.React中的diff算法 ⭐</h2> <p>React diff算法是react虚拟dom系统的核心，它允许react快速确定虚拟dom树上的哪些部分需要更新，从而使得UI更新非常的高效。</p> <ul><li><p>1.同级比较：React diff算法的基本策略是通过对树的层级进行比较，也就是意味着只会在同一层级的节点之间进行比较，而不是跨层级。</p></li> <li><p>2.元素类型：当在两棵树的相同位置找到两个不同类型的元素时，React 会直接卸载前一个元素及其所有子元素，并创建并挂载新的元素。</p></li> <li><p>3.类型相同，复用节点：如果两个元素是相同类型的，React 会保留 DOM 节点，并仅比较和更改它们之间的差异。</p></li> <li><p>4.Keys 的重要性：</p></li></ul> <p>当在数组中渲染子节点时，必须为每个子节点分配一个稳定的 key 值。通过为每个节点分配一个 key，React 可以使用这个 key 来识别那些在不同的渲染中仍然保持不变的元素。如果组件的数组顺序改变，但没有 key，React 将重新渲染大多数或所有组件。</p> <ul><li>5.递归子节点：一旦确定了两个元素是相同的类型并被复用，React 将递归地对其子节点进行比较。</li></ul> <h2 id="_4-react的状态管理库redux"><a href="#_4-react的状态管理库redux" class="header-anchor">#</a> 4.React的状态管理库Redux</h2> <p>redux是react的一个状态管理库。</p> <p>Redux 的三大原则：</p> <ul><li><p>1.单一数据源：应用的状态存储在唯一的 store 中。</p></li> <li><p>2.状态是只读的：唯一改变状态的方式是触发 action。</p></li> <li><p>2.使用纯函数执行修改：为了指定 action 如何改变状态，你需要编写 reducers。</p></li></ul> <p>常用概念：</p> <ul><li><p>1.Actions：描述发生了什么的对象。</p></li> <li><p>2.Reducers：指定每个 action 如何改变应用状态的函数。</p></li> <li><p>3.Store：将 Actions 和 Reducers 绑定在一起的对象。</p></li></ul> <p>Redux 通过解耦状态和 UI，使得状态管理更加明确和可预测。但也因为其模式和约束，对于一些简单的应用，使用 Redux 可能会显得过于复杂。不过，在大型应用和复杂状态管理场景下，Redux 的优势就显现出来了。</p> <h2 id="_5-react中的hooks"><a href="#_5-react中的hooks" class="header-anchor">#</a> 5.React中的hooks</h2> <p>React Hooks 是从 React 16.8 版本开始引入的一个新特性，它允许你在不使用类组件的情况下使用 state 和其他 React 特性。Hooks 的引入是为了解决类组件中的一些常见问题，如复杂性、重复的逻辑和组件之间的状态逻辑重用。</p> <p>常用的 React Hooks：</p> <ul><li><p>1.useState：允许函数组件使用状态</p></li> <li><p>2.useEffect：可以看作componentDidMount、componentDidUpdate、componentWillUnmount生命周期方法的结合。</p></li> <li><p>3.useMemo：会缓存计算结果，只有当数据变化的时候才会重新计算，用户避免不必要的计算，并优化函数组件性能。</p></li> <li><p>4.useRef：返回一个可变的ref对象</p></li></ul> <h2 id="_6-react-hooks和高阶组件差别"><a href="#_6-react-hooks和高阶组件差别" class="header-anchor">#</a> 6.React hooks和高阶组件差别</h2> <ul><li><p>1.hooks只能用于函数组件，而高阶组件可以用于函数组件和类组件</p></li> <li><p>2.hooks使用起来更加的简单，而高阶组件使用起来相对比较麻烦</p></li> <li><p>3.hooks没有那么多的层级嵌套，而高阶组件是有层级嵌套的</p></li> <li><p>4.hooks更容易组合，而高阶组件组合可能更加复杂</p></li></ul> <h2 id="_7-useeffect要注意的地方"><a href="#_7-useeffect要注意的地方" class="header-anchor">#</a> 7.useEffect要注意的地方</h2> <ul><li><p>1.正确处理依赖数组，因为依赖数组决定了<code>useEffect</code>的渲染频率</p></li> <li><p>2.如果有使用定时器的话，在组件卸载的时候要清理，以免造成内存泄漏</p></li> <li><p>3.不要在useEffect内使用async函数，避免造成不可预知的错误</p></li></ul> <h2 id="_8-usememo-usecallback差别"><a href="#_8-usememo-usecallback差别" class="header-anchor">#</a> 8.useMemo，useCallback差别</h2> <ul><li><p>1.useMemo是用于优化复杂计算的，可以记住之前已经计算过的结果</p></li> <li><p>2.useCallback是用于记住函数实例本身的，useCallback主要用于避免父组件渲染导致子组件不必要的渲染</p></li></ul> <h2 id="_9-react-的主要特点是什么"><a href="#_9-react-的主要特点是什么" class="header-anchor">#</a> 9.React 的主要特点是什么?</h2> <h3 id="_1-组件化"><a href="#_1-组件化" class="header-anchor">#</a> 1.组件化</h3> <p>React的应用是由多个组件组成的。组件可以被看作是独立的、可重复使用的代码块，它们各自管理自己的状态和渲染。</p> <h3 id="_2-数据驱动视图"><a href="#_2-数据驱动视图" class="header-anchor">#</a> 2.数据驱动视图</h3> <p>React是基于单向数据流的，就意味着在React应用中从父组件流向子组件（也就是props）。当数据改变时，UI自动更新；但反之并不是这样，UI中的改变不会直接回流影响数据。也就是说渲染界面，不应该直接操作dom，而是通过修改数据，数据驱动视图更新。</p> <h3 id="_3-虚拟dom"><a href="#_3-虚拟dom" class="header-anchor">#</a> 3.虚拟DOM</h3> <p>虚拟DOM是React用来提高性能的核心概念之一。它是一个在内存中的DOM的轻量级表示。当组件的状态改变时，React创建一个新的虚拟DOM树并与前一个树进行比较，然后决定如何进行有效的更新。</p> <h2 id="_10-react-生命周期"><a href="#_10-react-生命周期" class="header-anchor">#</a> 10.React 生命周期</h2> <h3 id="_1-挂载阶段"><a href="#_1-挂载阶段" class="header-anchor">#</a> 1.挂载阶段</h3> <p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p> <ul><li><p>1.constructor(): 在 React 组件挂载之前，会调用它的构造函数。</p></li> <li><p>2.getDerivedStateFromProps(): 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。</p></li> <li><p>3.render(): render() 方法是 class 组件中唯一必须实现的方法。</p></li> <li><p>4.componentDidMount(): 在组件挂载后（插入 DOM 树中）立即调用。</p></li></ul> <h3 id="_2-更新阶段"><a href="#_2-更新阶段" class="header-anchor">#</a> 2.更新阶段</h3> <p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p> <ul><li><p>1.getDerivedStateFromProps(): 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。</p></li> <li><p>2.shouldComponentUpdate():当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。</p></li> <li><p>3.render(): render() 方法是 class 组件中唯一必须实现的方法。</p></li> <li><p>4.getSnapshotBeforeUpdate(): 在最近一次渲染输出（提交到 DOM 节点）之前调用。</p></li> <li><p>5.componentDidUpdate(): 在更新后会被立即调用。</p></li></ul> <h3 id="_3-卸载阶段"><a href="#_3-卸载阶段" class="header-anchor">#</a> 3.卸载阶段</h3> <p>当组件从 DOM 中移除时会调用如下方法：</p> <ul><li>1.componentWillUnmount(): 在组件卸载及销毁之前直接调用。</li></ul> <h2 id="_11-react-中-refs-的作用是什么"><a href="#_11-react-中-refs-的作用是什么" class="header-anchor">#</a> 11.React 中 refs 的作用是什么？</h2> <ul><li>直接访问dom元素</li></ul> <h2 id="_12-说一下react中的类组件和函数式组件"><a href="#_12-说一下react中的类组件和函数式组件" class="header-anchor">#</a> 12.说一下React中的类组件和函数式组件</h2> <ul><li><p>1.写法：类组件使用 ES6 类，而函数式组件使用普通函数。</p></li> <li><p>2.状态管理：在引入 React Hooks 之前，类组件可以有状态，而函数式组件则是无状态的。</p></li> <li><p>3.生命周期方法：类组件可以使用所有的生命周期方法，而函数式组件在引入 React Hooks 之前不能使用它们。</p></li> <li><p>4.this 关键字：类组件可以使用 this，而函数式组件不能。</p></li></ul> <p>然后日常开发中是推荐使用函数组件的，因为写法更简洁，并且可以使用hooks提供的所有功能。</p> <h2 id="_13-什么是高阶组件"><a href="#_13-什么是高阶组件" class="header-anchor">#</a> 13.什么是高阶组件</h2> <p>高阶组件就是一个函数，这个函数接受一个组件作为参数，并返回一个新的组件。</p> <ul><li><p>1.代码重用：通过将组件包裹在高阶组件中，可以重用某些相似的逻辑，如数据获取、状态管理、props 修改等。</p></li> <li><p>2.渲染劫持：高阶组件可以控制被包裹组件的渲染过程，基于条件渲染不同的内容。</p></li> <li><p>3.Props 修改：可以添加新的 props 或修改传递给被包裹组件的 props。</p></li> <li><p>4.State 抽象和操作：高阶组件可以为其包裹的组件提供额外的状态或方法。</p></li> <li><p>5.访问生命周期方法：可以利用高阶组件在内部实现组件的生命周期方法。</p></li></ul> <p>注意：</p> <ul><li><p>1.不要在高阶组件内部改变原始组件。相反，通过组合来产生新组件。</p></li> <li><p>2.高阶组件不应该修改传入组件的原型。</p></li> <li><p>3.应避免无谓的嵌套：每使用一个高阶组件，组件树的深度都会增加一层。如果过度使用，可能会导致组件树过于复杂。</p></li></ul> <h2 id="_14-什么是受控组件"><a href="#_14-什么是受控组件" class="header-anchor">#</a> 14.什么是受控组件</h2> <p>在 React 中，当一个输入元素（如输入框和选择框）的值由组件的 state 控制时，我们称其为“受控组件”。</p> <h2 id="_15-说一下react-中的-props"><a href="#_15-说一下react-中的-props" class="header-anchor">#</a> 15.说一下React 中的 props?</h2> <p>React是单向数据流的，而父组件给子组件传递数据就是使用props的。</p> <p>props特性：</p> <ul><li><p>1.props是只读的，这意味着在一个组件内部，你不应该修改props。</p></li> <li><p>2.传递数据和函数：不仅可以传递数据，还可以传递函数，从而允许子组件与父组件交互。</p></li> <li><p>3.默认 Props：React 允许设置默认 props。这是当父组件没有提供某个 prop 时，组件可以有一个默认值。</p></li></ul> <h2 id="_16-状态和属性有什么区别"><a href="#_16-状态和属性有什么区别" class="header-anchor">#</a> 16.状态和属性有什么区别?</h2> <ul><li><p>1.props 是为了使组件在不同情况下重用，并允许数据从父组件流入子组件。</p></li> <li><p>2.state 是为了存储组件内部状态，以及响应用户的交互行为。</p></li></ul> <h2 id="_17-在组件库中当使用-forward-refs-时-你需要额外的注意"><a href="#_17-在组件库中当使用-forward-refs-时-你需要额外的注意" class="header-anchor">#</a> 17.在组件库中当使用 forward refs 时，你需要额外的注意?</h2> <p>forwardRef 是 React 提供的一个工具，允许组件接收并“转发”接收到的 ref 到其子组件。它对于某些组件类型，尤其是可能作为高阶组件或是库中的组件，特别有用。这是因为在很多情况下，你可能想要从父组件直接获取子组件的 DOM 节点，而不是通过中间组件。</p> <p>在 React 中，ref 并不是一个像 props 或 state 那样的属性。这意味着你不能直接将 ref 传递给子组件，除非使用特殊的手段。这就是 forwardRef 的用武之地。</p> <h2 id="_18-react-多个setstate会触发几次render"><a href="#_18-react-多个setstate会触发几次render" class="header-anchor">#</a> 18.react 多个setState会触发几次render</h2> <p>在react的本身的生命周期中或react事件处理器中（如onClick），连续多个setState会被批量处理，只会有一次render。</p> <p>但是在非react的异步代码中，例如setTimeout中，一次setState就会触发一次render，但是多次render并不代码会多次更新dom，因为react的虚拟dom的更新机制。</p> <h2 id="_19-setstate执行机制"><a href="#_19-setstate执行机制" class="header-anchor">#</a> 19.setState执行机制?</h2> <ul><li><p>1.异步执行：在大多数情况下，setState 是异步的。这意味着在调用 setState 后，状态不会立即更新。这是为了性能优化：当在短时间内多次调用 setState 时，React 会批量处理这些更新，从而避免不必要的重渲染。</p></li> <li><p>2.合并更新：当在一个事件处理函数中多次调用 setState 时，React 会将多个更新合并为一个更新。这意味着如果你多次对同一个状态字段调用 setState，只有最后一次的更新会被应用。</p></li> <li><p>3.触发重新渲染：一旦状态更新（和可能的 props 更新），React 会重新执行 render 方法来确定是否需要更新 DOM。在这个过程中，React 会执行其“diffing”算法来比较新旧虚拟 DOM，并只更新必要的部分。</p></li> <li><p>4.回调：setState 可以接受一个可选的第二个参数，这是一个在状态更新和组件渲染之后执行的回调函数。</p></li></ul> <h2 id="_20-react-router工作原理"><a href="#_20-react-router工作原理" class="header-anchor">#</a> 20.React-Router工作原理</h2> <ul><li>React-Router 的工作原理是通过监听浏览器地址栏的变化，并根据当前 URL 动态地渲染一组 React 组件。这个过程完全在客户端上完成，所以 React-Router 是一个单页应用（SPA）的路由解决方案。</li></ul> <h2 id="_21-react和vue的区别"><a href="#_21-react和vue的区别" class="header-anchor">#</a> 21.React和Vue的区别</h2> <ul><li>1.写法：</li></ul> <blockquote><p>React采用JSX的写法，允许在JS中混合html</p></blockquote> <blockquote><p>Vue采用基于HTML的模板语法</p></blockquote> <ul><li>2.数据可变性</li></ul> <blockquote><p>React采用数据不可变以及单向数据流</p></blockquote> <blockquote><p>Vue采用的是响应式数据的机制，数据更新视图自动更新。</p></blockquote> <ul><li>3.指令系统</li></ul> <blockquote><p>React没有指令的概念，所有事情都通过JS和JSX完成</p></blockquote> <blockquote><p>Vue有一系列内置的指令，例如：v-if、v-for</p></blockquote> <p>相对而言，Vue提供了更多的封装和内置功能，使得开发者可以更快地上手和开发。而React则提供了更大的自由度，允许开发者选择他们需要的工具和库。</p> <h2 id="_22-react18有哪些升级"><a href="#_22-react18有哪些升级" class="header-anchor">#</a> 22.React18有哪些升级</h2> <p><a href="https://zh-hans.react.dev/blog/2022/03/29/react-v18" target="_blank" rel="noopener noreferrer">官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>1.并发渲染</li></ul> <p>在React18之前，所有任务都被视为急迫任务，react18引入了并发模式，在这个模式下，渲染是可以中断的，高优先级的任务可以优先渲染更新。开启并发模式只需要将之前的ReactDom.render换成ReactDom.createRoot这个新的api即可。</p> <ul><li>2.批量更新</li></ul> <p>在React 18 之前，我们只在 React 事件处理函数 中进行批处理更新。默认情况下，在promise、setTimeout、原生事件处理函数中、或任何其它事件内的更新都不会进行批处理。React18之后，默认自动执行批处理，多次更新合并为一次更新。</p> <h2 id="_23-react的渲染过程"><a href="#_23-react的渲染过程" class="header-anchor">#</a> 23.React的渲染过程</h2> <p>首先我们就说react项目开发过程中运行的逻辑，首先例如你使用的是npm，启动npm run dev，这时候你的配置文件package.json中就有相对应的命令，如果你的打包工作使用的是webpack的花，运行相应的webpack命令，webpack从刚才的命令以及webpack中合并一个最终的配置参数，找到入口，一般是src文件根目录下的index.js，createRoot(document.getElementById('root')).render(<App></App>)</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/interview-blog/base/CSS.html" class="prev">
        2.CSS
      </a></span> <span class="next"><a href="/interview-blog/base/前端工程化.html">
        4.前端工程化
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/interview-blog/assets/js/app.e3b64c75.js" defer></script><script src="/interview-blog/assets/js/2.fe87fc20.js" defer></script><script src="/interview-blog/assets/js/23.048d7387.js" defer></script>
  </body>
</html>
